## 一个关于this的问题的拓展

### 背景

有天学妹问我，为什么箭头函数可以保证this的正确性呢？

仔细一想，好像从来没有探究过这个问题，惭愧惭愧，只知道用了箭头函数可以解决this漂移的问题，那就借此机会梳理一下知识。

### js的this

可能指向某个对象或者全局对象

### 如何改变js的this

- call, apply
- 对象调用
- bind

### react中的方法

- bind
- 箭头函数

### bind模拟实现

借用MDN的原话，

> bind()方法创建一个新的函数， 当这个新函数被调用时其this置为提供的值，其参数列表前几项置为创建时指定的参数序列。

做了如下事情：

- 返回一个函数

- 传入参数（第二个开始）

- 绑定this（第一个参数）

从MDN上可以看出，bind其实是Function.prototype.bind()这样的，也就是说是function原型上的方法。

所以可以通过在函数原型上创建一个方法来模拟bind，即Function.prototype.miniBind()

version1:

```javascript
Function.prototype.miniBind = function(context) {
  const self = this;  // 此处的this，就是调用miniBind的函数本身，因为这个函数是Function的一个实例

  return function() {
    return self.apply(context);
  }
}
```

> 绑定函数也可以使用new运算符构造：这样做就好像已经构造了目标函数一样。提供的this值将被忽略，而前置参数将提供给模拟函数。

加之各种属性，比如传参，原型链，类型判断，直接上一个比较完整的版本。

```javascript
Function.prototype.miniBind = function(context) {
  const self = this;
  if (typeof self !== 'function') throw new Error();

  const args = Array.prototype.slice.call(arguments, 1);  // 这里的arguments是bind时传入的参数

  const fNOP = function() {};

  const fBound = function () {
    const bindArgs = Array.prototype.slice.call(arguments); //  这里的arguments是bind返回的函数调用时的参数
    return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
  }

  fNOP.prototype = self.prototype;
  fBound.prototype = new fNOP();

  return fBound;
}
```

```javascript
// es6 version
Function.prototype.miniBind = function(context, ...rest) {
  const self = this;
  if (typeof self !== 'function') throw new Error();

  return function F(...args) {
    if (this instanceof F) return new self(...rest, ...args);

    return self.apply(context, rest.concat(args));
  }
}
```

### 箭头函数