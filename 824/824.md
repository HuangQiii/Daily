## loader

#### 形式

```
const loaderUtils = require('loader-utils');

module.exports = function(source) {
  // 自带缓存，可通过this.cacheable(false)关闭
  // 获取用户传入的opts
  const options = loaderUtils.getOptions(this);
  // do something
  return source;
}V
```

#### callback

```
const loaderUtils = require('loader-utils');

module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  // do something
  // this.callback是webpack注入loader的api，必须返回undefined，让webpack知道loader返回结果在callback里
  this.callback(null, source, sourceMaps);
  return;
}
```

callback详细

```
this.callback(
  // 无法转化时，报错
  err: Error | null,
  content: string | Buffer,
  // 通过转化后的内容得出原内容的source map
  sourceMap?: SourceMap,
  // 如果这次转化生成ast则返回，让之后的loader使用提高性能
  abstractSyntaxTree?: AST, 
)
```

如果有sourceMap,根据`this.sourceMap`获取当前构建环境，根据开发和发布环境做区别

异步callback

```
const loaderUtils = require('loader-utils');

module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  let callback = this.async();
  // do something
  someAsyncOperation(source, (err, result, sourceMaps, ast) => {
    callback(err, result, sourceMaps, ast);
  });
}
```

apis
// 路径类型: /src/main.js?id=1
this.context:/src
this.resource:/src/main.js?id=1
this.resourcePath:src/main.js
this.resourceQuery:name=1

this.target
this.loadModule
this.resolve
this.addDependency
this.addContextDependency
this.clearDependencies
this.emitFile


## plugin

#### 形式

```
class BasicPlugin {
  constructor(options) {

  }

  apply(compilter) {
    compilter.plugin('compilation', (compilation, callback) => {
      // do something
      // 如果不执行callback,就会卡住
      callback();
    })
  }
}

module.exports = BasicPlugin;
// webpack启动后，读取配置时会先执行new BasicPlugin(options)
// 初始化一个实例
// 初始化comiler对象后，调用basicPlugin.apply(compiler)传入compiler对象
// 实力获取到compiler后，通过compiler.plugin监听webpack的广播事件
```

读取输出资源、代码块、模块及其依赖
```
class Plugin {
  constructor(options) {

  }

  apply(compilter) {
    compilter.plugin('emit', (compilation, callback) => {
      compilation.chunks.forEach((chunk) => {
        chunk.forEachModule((module) => {
          // 当前模块所有依赖的文件路径
          module.fileDependencies.forEach((filePath) => {
          });
        });
        chunk.files.forEach((fileName) => {
          // compilation.assets当前即将输出的所有资源
          let source = compilation.assets[fileName].source();
        });
      });
      callback();
    })
  }
}

module.exports = Plugin;
```

监听文件变化
```
class Plugin {
  constructor(options) {

  }

  apply(compilter) {
    compilter.plugin('watch-run', (watching, callback) => {
      // 获取发生变化的文件列表
      const changedFiles = watching.compilter.watchFileSystem.watcher.mtimes;
      if (changedFiles[filePath] !== undefined) {}
      callback();
    })
  }
}

module.exports = Plugin;
```

修改输出资源
```
class Plugin {
  constructor(options) {

  }

  apply(compilter) {
    compilter.plugin('emit', (compilation, callback) => {
      // 修改
      compilation.assets[fileName] = {
        source: () => {
          return fileContent;
        },
        size: () => {
          return Buffer.byteLength(fileContent, 'utf8');
        }
      };
      // 读取
      const assets = compilation.assets[fileName];
      assets.source();
      assets.siz();
      callback();
    })
  }
}

module.exports = Plugin;
```

判断是否使用某些插件
```
function hasUsePlugin(compilter) {
  const plugins = compilter.options.plugins;
  return plugins.find(plugin => plugin.__proto__.constructor === ExtractTextPlugin) != null;
}

class Plugin {
  constructor(options) {

  }

  apply(compilter) {
    compilter.plugin('emit', (compilation, callback) => {
      hasUsePlugin(compilter);
      callback();
    })
  }
}

module.exports = Plugin;
```
